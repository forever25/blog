# webGL初探

> 2023年了，作为前端应该想办法提高自己的竞争力，webGL算是一个不错的选择。

## 什么是WebGL

WebGL（Web 图形库）是一个 JavaScript API，可在任何兼容的 Web 浏览器中渲染高性能的交互式 3D 和 2D 图形，而无需使用插件。WebGL 通过引入一个与 OpenGL ES 2.0 非常一致的 API 来做到这一点，该 API 可以在 HTML5 `<canvas>` 元素中使用。这种一致性使 API 可以利用用户设备提供的硬件图形加速。

![](https://cdn.jsdelivr.net/gh/forever25/picture-bed@main/Snipaste_2023-06-09_10-15-08.png)

左图为普通网页右侧为使用了WebGL的网页软件结构

## 最短的WebGL程序：清空绘图区域

```TypeScript
function main() {
  const canvas = document.querySelector('#example') as HTMLCanvasElement;
  const gl = canvas.getContext('webgl')!; // 获取webGL对象

  gl.clearColor(0, 0, 0, 1); // 指定绘图区域背景颜色 格式为 rgba
  gl.clear(gl.COLOR_BUFFER_BIT); // 使用背景色填充绘图区域
}

window.onload = () => {
  main();
};
export {};
```

### 使用到的API

|语法|参数|返回值|说明|
|----|----|----|----|
gl.clearColor(mask) | mask：gl.COLOR_BUFFER_BIT //颜色缓冲区 <br /> gl.DEPTH_BUFFER_BIT //深度缓冲区 <br />gl.STENCIL_BUFFER_BIT //模板缓冲区 | 无 | 使用预设值来清空缓冲,预设值可以用  clearColor() clearDepth() clearStencil() 设置
gl.clearColor(red, green, blue, alpha) | 略 | 无 | 用于设置清空颜色缓冲时的颜色值

## 绘制一个点

main.ts

```TypeScript
import { initShaders } from '../../../libs/webgl-utils';

// 顶点着色器
const VSHADER_SOURCE = `
void main() {
  gl_Position = vec4(0.0, 0.0, 0.0, 1.0); // 坐标
  gl_PointSize = 20.0;  // 尺寸
}
`;

// 片元着色器
const FSHADER_SOURCE = `
void main() {
  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // 设置颜色
}
`;

function main() {
  const canvas = document.querySelector('#example') as HTMLCanvasElement;
  const gl = canvas.getContext('webgl')!;

  const program = initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE);

  gl.clearColor(1, 1, 1, 1);
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.drawArrays(gl.POINTS, 0, 1);
}

window.onload = () => {
  main();
};

export {};

```

webgl-utils.ts

```TypeScript
export function initShaders(gl: WebGLRenderingContext, vshader: string, fshader: string) {
  const program = createProgram(gl, vshader, fshader);

  gl.useProgram(program);

  return program;
}

function createProgram(gl: WebGLRenderingContext, vshader: string, fshader: string) {
  const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vshader);
  const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fshader);

  const program = gl.createProgram()!;

  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);

  gl.linkProgram(program);

  const linked = gl.getProgramParameter(program, gl.LINK_STATUS);

  if (!linked) {
    var info = gl.getProgramInfoLog(program);
    throw 'WebGL program 不能编译。\n\n' + info;
  }

  return program;
}

function loadShader(gl: WebGLRenderingContext, type: number, source: string) {
  const shader = gl.createShader(type)!;

  gl.shaderSource(shader, source);
  gl.compileShader(shader);

  const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

  return shader;
}
```
